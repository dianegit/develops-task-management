# Deployment Guide

This guide covers the complete deployment process for the Task Manager application.

## Prerequisites

Before deploying, ensure you have:

- ✅ Azure account with active subscription
- ✅ GitHub account
- ✅ Terraform Cloud account (organization: `dianeee`)
- ✅ Azure Service Principal credentials
- ✅ SSH key pair generated
- ✅ All GitHub secrets configured

## Infrastructure Provisioning

### Step 1: Configure Terraform Cloud Workspace

1. **Login to Terraform Cloud**
   - Go to https://app.terraform.io
   - Navigate to organization: `dianeee`
   - Create workspace: `devops-pipeline-infrastructure`
   - Choose "CLI-driven workflow"

2. **Set Required Variables in Terraform Cloud**

Go to workspace → Variables tab → Environment Variables:

```
ARM_CLIENT_ID          = <your-azure-service-principal-client-id>
ARM_CLIENT_SECRET      = <your-azure-service-principal-secret>      [SENSITIVE]
ARM_SUBSCRIPTION_ID    = <your-azure-subscription-id>
ARM_TENANT_ID          = <your-azure-tenant-id>
```

3. **Configure GitHub Secrets**

Go to your repository → Settings → Secrets and variables → Actions:

```bash
# Run helper script to generate secrets
.\scripts\setup-github-secrets.ps1

# View generated secrets
notepad .\scripts\github-secrets.txt
```

Add the following secrets to GitHub:
- `TF_API_TOKEN` - Terraform Cloud API token
- `SSH_PUBLIC_KEY` - Content of devops-pipeline.pub
- `SSH_PRIVATE_KEY` - Content of devops-pipeline (private key)
- `SECRET_KEY` - Backend secret key (generated by script)
- `DB_USER` - Database username (generated by script)
- `DB_PASSWORD` - Database password (generated by script)
- `DB_NAME` - Database name (generated by script)

### Step 2: Deploy Infrastructure

1. **Push Changes to Main Branch**

```bash
git add .
git commit -m "Initial infrastructure setup"
git push origin main
```

2. **Monitor Terraform Workflow**

- Go to GitHub → Actions → Terraform Infrastructure workflow
- Watch the pipeline execute:
  - Terraform Format Check
  - Terraform Init
  - Terraform Validate
  - Terraform Plan
  - Security Scans (tfsec, Checkov)
  - Terraform Apply (on main branch only)

3. **Extract Terraform Outputs**

After successful deployment:

```bash
# Extract outputs
.\scripts\extract-terraform-outputs.ps1

# View outputs
notepad .\terraform-secrets.txt
```

Add the following secrets to GitHub:
- `VM_PUBLIC_IP` - Azure VM public IP address
- `ACR_NAME` - Azure Container Registry name
- `ACR_LOGIN_SERVER` - ACR login server URL
- `ACR_USERNAME` - ACR admin username
- `ACR_PASSWORD` - ACR admin password

## Application Deployment

### Automated Deployment (Recommended)

Once all secrets are configured, deployment happens automatically:

1. **Merge Changes to Main Branch**

```bash
git checkout main
git pull origin main
git push origin main
```

2. **Monitor CI/CD Pipeline**

Go to GitHub → Actions and monitor these workflows:

**CI Pipeline** (`ci.yml`):
- ✅ Backend linting (flake8)
- ✅ Frontend linting (ESLint)
- ✅ Security scans (Bandit, Safety, npm audit)
- ✅ Docker image builds
- ✅ Container scanning (Trivy)

**CD Pipeline** (`cd-pipeline.yml`):
- ✅ Build Docker images (backend, frontend)
- ✅ Push to Azure Container Registry
- ✅ Security scan images (Trivy)
- ✅ Deploy with Ansible to Azure VM
- ✅ Post-deployment smoke tests
- ✅ Health checks

3. **Access Deployed Application**

After successful deployment:
- **Frontend**: `http://<VM_PUBLIC_IP>:3000`
- **Backend API**: `http://<VM_PUBLIC_IP>:8000`
- **API Docs**: `http://<VM_PUBLIC_IP>:8000/api/docs`
- **Health Check**: `http://<VM_PUBLIC_IP>:8000/health`

### Manual Deployment (Alternative)

If you need to deploy manually:

```bash
# Navigate to ansible directory
cd ansible

# Install required collections
ansible-galaxy collection install azure.azcollection
ansible-galaxy collection install community.docker

# Create static inventory
cat > inventory/hosts << EOF
[app_servers]
azure-vm ansible_host=<VM_PUBLIC_IP> ansible_user=azureuser
EOF

# Set environment variables
export ACR_NAME="<acr-name>"
export ACR_LOGIN_SERVER="<acr-login-server>"
export ARM_CLIENT_ID="<client-id>"
export ARM_CLIENT_SECRET="<client-secret>"
export ARM_TENANT_ID="<tenant-id>"
export IMAGE_TAG="latest"
export DB_USER="taskuser"
export DB_PASSWORD="<db-password>"
export DB_NAME="taskmanager"
export SECRET_KEY="<secret-key>"

# Run deployment
ansible-playbook playbooks/setup-server.yml -i inventory/hosts -v
```

## CI/CD Pipelines

### CI Pipeline (`ci.yml`)

Runs on every push and pull request:

**Quality Checks**:
- Backend linting with flake8
- Frontend linting with ESLint
- Code formatting validation

**Security Scans**:
- Backend: Bandit (SAST), Safety (dependencies)
- Frontend: npm audit
- Docker: Trivy container scanning

**Build Verification**:
- Build backend Docker image
- Build frontend Docker image
- Cache layers for faster builds

### CD Pipeline (`cd-pipeline.yml`)

Runs on push to `main` branch:

**Image Build & Push**:
- Build backend image with metadata
- Build frontend image with metadata
- Tag with SHA and `latest`
- Push to Azure Container Registry
- Scan images with Trivy

**Deployment**:
- Install Ansible on runner
- Setup SSH authentication
- Run Ansible playbook
- Deploy Docker Compose stack
- Verify application health

**Post-Deployment**:
- Smoke tests on frontend
- Backend health check
- API endpoint validation

### Terraform Pipeline (`terraform.yml`)

Runs on changes to `terraform/**`:

**Plan Phase**:
- Format check
- Initialize Terraform
- Validate configuration
- Generate plan

**Security Phase**:
- tfsec scanning
- Checkov policy checks

**Apply Phase** (main branch only):
- Apply infrastructure changes
- Extract and save outputs
- Upload artifacts

### Security Pipeline (`security.yml`)

Runs on push, PR, and weekly schedule:

**Dependency Scanning**:
- Python: Safety
- JavaScript: npm audit

**SAST**:
- CodeQL analysis
- Semgrep scanning

**Secret Scanning**:
- TruffleHog for exposed secrets

**Container Scanning**:
- Trivy on backend image
- Trivy on frontend image

**IaC Security**:
- tfsec on Terraform
- Checkov on Terraform
- ansible-lint on playbooks

### DAST Pipeline (`dast.yml`)

Runs weekly and on-demand:

**OWASP ZAP Scans**:
- Baseline scan
- Full scan with custom rules
- Generate HTML/JSON reports

## Verification

### Post-Deployment Checks

1. **Check Container Status**

```bash
ssh azureuser@<VM_PUBLIC_IP>
docker ps
```

Expected output:
```
CONTAINER ID   IMAGE                                        STATUS
xxxxx          taskmanager-frontend:latest                  Up 5 minutes
xxxxx          taskmanager-backend:latest                   Up 5 minutes
xxxxx          postgres:15-alpine                           Up 5 minutes
```

2. **Check Application Logs**

```bash
cd /opt/taskmanager-app
docker-compose logs -f
```

3. **Test Endpoints**

```bash
# Health check
curl http://<VM_PUBLIC_IP>:8000/health

# Frontend
curl http://<VM_PUBLIC_IP>:3000

# API docs
curl http://<VM_PUBLIC_IP>:8000/api/docs
```

4. **System Monitoring**

```bash
# Run system status script
/usr/local/bin/system-status.sh

# Check Prometheus metrics
curl http://<VM_PUBLIC_IP>:9100/metrics
```

## Rollback Procedure

If deployment fails or issues are detected:

1. **Revert Docker Images**

```bash
ssh azureuser@<VM_PUBLIC_IP>
cd /opt/taskmanager-app

# Edit docker-compose.yml to use previous tag
# Change: taskmanager-backend:sha-abc123
# To:     taskmanager-backend:sha-xyz789

docker-compose down
docker-compose pull
docker-compose up -d
```

2. **Rollback Infrastructure**

```bash
cd terraform
# Revert to previous state
terraform state pull > backup.tfstate
terraform apply -target=<resource-to-fix>
```

## Production Checklist

Before deploying to production:

- [ ] All secrets configured in GitHub
- [ ] Azure credentials configured in Terraform Cloud
- [ ] SSH keys generated and configured
- [ ] DNS configured (if using custom domain)
- [ ] SSL certificates obtained (if using HTTPS)
- [ ] Backup strategy implemented
- [ ] Monitoring dashboards set up
- [ ] Alert recipients configured
- [ ] Security scans passing
- [ ] All tests passing
- [ ] Documentation updated
- [ ] Team notified of deployment

## Maintenance

### Regular Updates

1. **Weekly Security Scans** (automated)
   - DAST scan runs every Sunday
   - Review results in GitHub Actions

2. **Monthly Dependency Updates**
   - Review Dependabot PRs
   - Test and merge updates
   - Redeploy application

3. **Quarterly Infrastructure Review**
   - Review Terraform state
   - Check for Azure service updates
   - Optimize resource sizing

### Monitoring & Alerts

Check these regularly:
- GitHub Actions workflow runs
- Azure VM metrics
- Application logs
- Security scan results
- Docker container health

## Cost Management

### Azure Resources Costs

Approximate monthly costs:
- VM (Standard_B2s): ~$35/month
- Container Registry (Basic): ~$5/month
- Public IP: ~$3/month
- Data Transfer: Variable
- **Total**: ~$45-50/month

### Cost Optimization Tips

- Use Azure Reserved Instances for VMs
- Clean up unused container images
- Monitor data transfer costs
- Use Azure Cost Management tools

## Support

For deployment issues:
- Check [Troubleshooting Guide](TROUBLESHOOTING.md)
- Review GitHub Actions logs
- Check Azure Portal for infrastructure issues
- Review Terraform Cloud run logs
- Contact team via GitHub Issues
